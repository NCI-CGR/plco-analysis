## Cameron Palmer, 19 May 2020
## Generate genetic relatedness matrices for FASTGWA from cleaned ancestry-split genotype data

include $(PROJECT_BASE_DIR)/Makefile.config
.DELETE_ON_ERROR:
.SECONDARY:
.SECONDEXPANSION:

## number of subsets into which to partition the genome
N_SPLITS := 3
SPLIT_SEQ := $(shell seq 1 $(N_SPLITS))
INPUT_DIR := $(CLEANED_CHIP_OUTPUT_DIR)
OUTPUT_DIR := $(FASTGWA_GRM_OUTPUT_DIR)
## detects valid ancestry/platform combinations from chip cleaning pipeline. Defaults to N>=10 per ancestry/platform combination
VALID_INPUTS := $(shell find $(INPUT_DIR) -maxdepth 2 -iname "*step3.pruning.bed" -print)
VALID_OUTPUTS := $(foreach input,$(VALID_INPUTS),$(subst .step3.pruning.bed,-sp.grm.sp.success,$(subst $(INPUT_DIR),$(OUTPUT_DIR),$(input))))

.PHONY: all
all: $(VALID_OUTPUTS)

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}-sp.grm.sp
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.grm.bin
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.grm.id
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.grm.N.bin
## Notes: round 2, make an existing GRM sparse
%-sp.grm.sp.success: %.grm.bin %.grm.id %.grm.N.bin | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),$(GCTA) --grm $(subst .grm.bin,,$<) --make-bK-sparse 0.05 --out $(subst .grm.sp.success,,$@))


## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.grm.N.bin
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin.success
## Notes: merge .grm.N.bin files from round 1
$(subst -sp.grm.sp.success,.grm.N.bin,$(VALID_OUTPUTS)): $$(patsubst %,$$(subst .grm.N.bin,,$$@).part_$$(N_SPLITS)_%.grm.bin.success,$$(SPLIT_SEQ)) | $$(dir $$@)
	cat $(subst .grm.bin.success,.grm.N.bin,$^) > $@

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.grm.id
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin.success
## Notes: merge .grm.id files from round 1
$(subst -sp.grm.sp.success,.grm.id,$(VALID_OUTPUTS)): $$(patsubst %,$$(subst .grm.id,,$$@).part_$$(N_SPLITS)_%.grm.bin.success,$$(SPLIT_SEQ)) | $$(dir $$@)
	cat $(subst .grm.bin.success,.grm.id,$^) > $@

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.grm.bin
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin.success
## Notes: merge .grm.bin files from round 1
$(subst -sp.grm.sp.success,.grm.bin,$(VALID_OUTPUTS)): $$(patsubst %,$$(subst .grm.bin,,$$@).part_$$(N_SPLITS)_%.grm.bin.success,$$(SPLIT_SEQ)) | $$(dir $$@)
	cat $(subst .success,,$^) > $@

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin.success
##    input:  cleaned-chips/{ANCESTRY}/{CHIP}.step6.bed
## Notes: round 1, break dataset into chunks and create GRMs within chunks
$(foreach output,$(VALID_OUTPUTS),$(patsubst %,$(subst -sp.grm.sp.success,,$(output)).part_$(N_SPLITS)_%.grm.bin.success,$(SPLIT_SEQ))): $$(word 1,$$(subst $$(OUTPUT_DIR),$$(INPUT_DIR),$$(subst .part_$$(N_SPLITS), ,$$@))).step6.bed | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),$(GCTA) --bfile $(subst .bed,,$<) --make-grm-part $(N_SPLITS) $(word 2,$(subst .part_$(N_SPLITS)_, ,$(subst .grm.bin.success,,$@))) --thread-num $(N_THREADS) --out $(word 1,$(subst .part_$(N_SPLITS)_, ,$(subst .grm.bin.success,,$@))))

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/
$(sort $(dir $(VALID_OUTPUTS))):
	mkdir -p $@
