## Cameron Palmer, 19 May 2020
## Generate genetic relatedness matrices for FASTGWA from cleaned ancestry-split genotype data

include $(PROJECT_BASE_DIR)/Makefile.config
.DELETE_ON_ERROR:
.SECONDARY:
.SECONDEXPANSION:

## number of subsets into which to partition the genome
N_SPLITS := 3
SPLIT_SEQ := $(shell seq 1 $(N_SPLITS))
INPUT_DIR := $(CLEANED_CHIP_OUTPUT_DIR)
OUTPUT_DIR := $(FASTGWA_GRM_OUTPUT_DIR)
## detects valid ancestry/platform combinations from chip cleaning pipeline. Defaults to N>=10 per ancestry/platform combination
VALID_INPUTS := $(shell find $(INPUT_DIR) -maxdepth 2 -iname "*step3.pruning.bed" -print)
VALID_OUTPUTS := $(foreach input,$(VALID_INPUTS),$(subst .step3.pruning.bed,-sp.grm.sp$(TRACKING_SUCCESS_SUFFIX),$(subst $(INPUT_DIR),$(OUTPUT_DIR),$(input))))

.PHONY: all
all: $(VALID_OUTPUTS)

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}-sp.grm.sp.success
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.grm.bin.success
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.grm.id.success
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.grm.N.bin.success
## Notes: round 2, make an existing GRM sparse
%-sp.grm.sp$(TRACKING_SUCCESS_SUFFIX): %.grm.bin.success %.grm.id.success %.grm.N.bin.success | $$(dir $$@)
	$(call qsub_handler,$(subst $(TRACKING_SUCCESS_SUFFIX),,$@),$(GCTA) --grm $(subst .grm.bin,,$<) --make-bK-sparse 0.05 --out $(subst .grm.sp$(TRACKING_SUCCESS_SUFFIX),,$@))


## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.grm.N.bin.success
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin$(TRACKING_SUCCESS_SUFFIX)
## Notes: merge .grm.N.bin files from round 1
$(subst -sp.grm.sp,.grm.N.bin,$(VALID_OUTPUTS)): $$(patsubst %,$$(subst .grm.N.bin.success,,$$@).part_$$(N_SPLITS)_%.grm.bin$(TRACKING_SUCCESS_SUFFIX),$$(SPLIT_SEQ)) | $$(dir $$@)
	$(call log_handler,$(subst .success,,$@),cat $(subst .grm.bin$(TRACKING_SUCCESS_SUFFIX),.grm.N.bin,$^) > $(subst .success,,$@))

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.grm.id.success
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin$(TRACKING_SUCCESS_SUFFIX)
## Notes: merge .grm.id files from round 1
$(subst -sp.grm.sp,.grm.id,$(VALID_OUTPUTS)): $$(patsubst %,$$(subst .grm.id.success,,$$@).part_$$(N_SPLITS)_%.grm.bin$(TRACKING_SUCCESS_SUFFIX),$$(SPLIT_SEQ)) | $$(dir $$@)
	$(call log_handler,$(subst .success,,$@),cat $(subst .grm.bin$(TRACKING_SUCCESS_SUFFIX),.grm.id,$^) > $(subst .success,,$@))

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.grm.bin.success
##    input:  fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin$(TRACKING_SUCCESS_SUFFIX)
## Notes: merge .grm.bin files from round 1
$(subst -sp.grm.sp,.grm.bin,$(VALID_OUTPUTS)): $$(patsubst %,$$(subst .grm.bin.success,,$$@).part_$$(N_SPLITS)_%.grm.bin$(TRACKING_SUCCESS_SUFFIX),$$(SPLIT_SEQ)) | $$(dir $$@)
	$(call log_handler,$(subst .success,,$@),cat $(subst $(TRACKING_SUCCESS_SUFFIX),,$^) > $(subst .success,,$@))

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/{CHIP}.part_{TOTALPARTS}_{CURRENTPART}.grm.bin$(TRACKING_SUCCESS_SUFFIX)
##    input:  cleaned-chips/{ANCESTRY}/{CHIP}.step6.bed
## Notes: round 1, break dataset into chunks and create GRMs within chunks
$(foreach output,$(VALID_OUTPUTS),$(patsubst %,$(subst -sp.grm.sp$(TRACKING_SUCCESS_SUFFIX),,$(output)).part_$(N_SPLITS)_%.grm.bin$(TRACKING_SUCCESS_SUFFIX),$(SPLIT_SEQ))): $$(word 1,$$(subst $$(OUTPUT_DIR),$$(INPUT_DIR),$$(subst .part_$$(N_SPLITS), ,$$@))).step6.bed | $$(dir $$@)
	$(call qsub_handler,$(subst $(TRACKING_SUCCESS_SUFFIX),,$@),$(GCTA) --bfile $(subst .bed,,$<) --make-grm-part $(N_SPLITS) $(word 2,$(subst .part_$(N_SPLITS)_, ,$(subst .grm.bin$(TRACKING_SUCCESS_SUFFIX),,$@))) --thread-num $(N_THREADS) --out $(word 1,$(subst .part_$(N_SPLITS)_, ,$(subst .grm.bin$(TRACKING_SUCCESS_SUFFIX),,$@))))

## patterns:
##    output: fastgwa-grm/{ANCESTRY}/
$(sort $(dir $(VALID_OUTPUTS))):
	mkdir -p $@
