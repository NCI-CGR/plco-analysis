## Cameron Palmer, 21 May 2020
## Shared pipeline for each ancestry in turn, pulled in through an include from a dummy makefile controller.
## Note that this means that this is executed from within the {ANCESTRY} directory, and output paths don't include that
## Ancestry is stored in "POPULATION_NAME"

include $(PROJECT_BASE_DIR)/Makefile.config

.PHONY: all all_chips
.SECONDARY:
.SECONDEXPANSION:
.DELETE_ON_ERROR:
all: all_chips

FINAL_CHIP_DATA := $(CHIP_FREEZE_INPUT_DIR)

## emits subject IDs for all subjects on a given platform matching a specified ancestry.
## intersects this with a chip famfile in case the ancestry data are a superset of the chip (this was relevant earlier in the cleaning process, but shouldn't be so now)
define ancestry_extract
sed 's/ /_/g' $(ANCESTRY_OUTPUT_DIR)/PLCO_$(2).graf_estimates.txt | awk '/\t$(1)$$/ {print $$1}' | sort | uniq | cat - $(FINAL_CHIP_DATA)/PLCO_$(2).fam | awk '{print $$1}' | sed 's/_//g' | sort | uniq -d
endef

## get all the platforms that have at least the minimum required number of subjects for cleaning (defaults to 10)
VALID_STUDIES := $(foreach STUDY,$(STUDIES),$(shell if [[ $$($(call ancestry_extract,$(POPULATION_NAME),$(STUDY)) | wc -l) -gt $(SAMPLE_SIZE_MIN) ]] ; then echo "$(STUDY)" ; fi))

## get all the platforms that have at least the minimum number of subjects for quasiparallelized IBS/IBD estimation
LARGE_STUDIES := $(foreach STUDY,$(STUDIES),$(shell if [[ $$($(call ancestry_extract,$(POPULATION_NAME),$(STUDY)) | wc -l) -gt $(SAMPLE_SIZE_LARGE) ]] ; then echo "$(STUDY)" ; fi))

## get the platforms that can just run in a single --genome IBS/IBD run, as the complement of the above
SMALL_STUDIES := $(filter-out $(LARGE_STUDIES),$(VALID_STUDIES))

## build target suffixes based on the set number of splits per quasiparallelized --genome platform
LARGE_STUDY_SUFFIXES := $(patsubst %,.genome.%.gz,$(shell seq 1 $(GENOME_GZ_JOB_SPLIT)))

## all targets are: IBS/IBD estimates; autosomal genomes without heterozygosity outliers; within-cleaned-platform-ancestry-subset GRAF relatedness estimates; PCA results
all_chips: $(addsuffix .success,$(patsubst %,%.step5.ibs-normal.genome.gz,$(SMALL_STUDIES)) $(patsubst %,%.step5.ibs-split.genome.gz,$(LARGE_STUDIES)) $(patsubst %,%.nohet.autosomes.bed,$(VALID_STUDIES)) $(patsubst %,%.graf_relatedness.txt,$(VALID_STUDIES)) $(patsubst %,%.step7.evec,$(VALID_STUDIES)))

## patterns:
##    output: {CHIP}.graf_relatedness.txt.success
##    input:  {CHIP}.fpg.success
## Notes: this duplicates content from the relatedness pipeline
%.graf_relatedness.txt.success: %.fpg.success
	-$(call log_handler,$(subst .success,,$@),$(GRAF_EXECUTABLE) -geno $(subst .success,,$<) -out $(subst .success,,$@))

## patterns:
##    output: {CHIP}.fpg.success
##    input:  {CHIP}.rsids.bed.success
## Notes: this duplicates content from the relatedness pipeline
%.fpg.success: %.rsids.bed.success
	-$(call log_handler,$(subst .success,,$@),$(GRAF_EXECUTABLE) -exfp $(subst .bed.success,,$<) -out $(subst .success,,$@) -type 4)

## patterns:
##    output: {CHIP}.rsids.bed.success (and bim, and fam)
##    input:  {CHIP}.nohet.autosomes.bed.success
##    input:  GRAF.extract.success
##    input:  GRAF.update_names.success
## Notes: this duplicates content from the relatedness pipeline
%.rsids.bed.success: %.nohet.autosomes.bed.success GRAF.extract.success GRAF.update_names.success
	$(call log_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --extract $(subst .success,,$(word 2,$^)) --update-name $(subst .success,,$(word 3,$^)) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: GRAF.extract.success
##    input:  {GRAF_backend_bimfile}
## Notes: this duplicates content from the relatedness pipeline
GRAF.extract.success: $(GRAF_1KG_VARIANT_BIMFILE)
	$(call log_handler,$(subst .success,,$@),awk '{print $$2}' $< > $(subst .success,,$@))

## patterns:
##    output: GRAF.update_names.success
##    input:  {GRAF_backend_bimfile}
## Notes: this duplicates content from the relatedness pipeline
GRAF.update_names.success: $(GRAF_1KG_VARIANT_BIMFILE)
	$(call log_handler,$(subst .success,,$@),awk '{print $$1":"$$4"\t"$$2}' $< > $(subst .success,,$@))



## patterns:
##    output: {CHIP}.nohet.autosomes.bed.success (and bim, and fam)
##    input:  {CHIP}.step1.maf.geno.hwe.bed.success
##    input:  {CHIP}.step4.het.remove.success
## Notes: this applies the heterozygosity filter from step4. Note that in practice in the cleaned dataset, the remove
## file typically contains no people as it was used to flag iteratively removed subjects upstream
%.nohet.autosomes.bed.success: %.step1.maf.geno.hwe.bed.success %.step4.het.remove.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --remove $(subst .success,,$(word 2,$^)) --autosome --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: {CHIP}.ancestry.keep.success
##    input:  {ANCESTRY_PIPELINE}/PLCO_{CHIP}.graf_estimates.txt
## Notes: assumes the ancestry pipeline has already been run; top level makefile controls this behavior
%.ancestry.keep.success: $(ANCESTRY_OUTPUT_DIR)/PLCO_$$(subst .ancestry.keep.success,,$$@).graf_estimates.txt
	$(call log_handler,$(subst .success,,$@),$(call ancestry_extract,$(POPULATION_NAME),$(subst .ancestry.keep.success,,$@)) | awk -F"\t" '{print $$1"\t"$$1}' > $(subst .success,,$@))

## patterns:
##    output: {CHIP}.step0.ancestry.bed.success (and bim, and fam)
##    input:  {CHIP_FREEZE}/PLCO_{CHIP}.bed
##    input:  {CHIP}.ancestry.keep.success
## Notes: get subjects from this platform of the currently processed ancestry
%.step0.ancestry.bed.success: $(FINAL_CHIP_DATA)/PLCO_%.bed %.ancestry.keep.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed,,$<) --keep $(subst .success,,$(word 2,$^)) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: {CHIP}.step1.maf.geno.hwe.bed.success (and bim, and fam)
##    input:  {CHIP}.step0.ancestry.bed.success
## Notes: apply MAF, HWE, genotype missingness filters. Pretty stringent relative to CGR defaults; likely too stringent for admixed pops
%.step1.maf.geno.hwe.bed.success: %.step0.ancestry.bed.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --maf 0.01 --geno 0.02 --hwe 0.001 --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: {CHIP}.step2.pruning.prune.in.success
##    input:  {CHIP}.step1.maf.geno.hwe.bed.success
## Notes: compute variant inclusion list from first pass LD pruning
%.step2.pruning.prune.in.success: %.step1.maf.geno.hwe.bed.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --indep 50 5 2 --out $(subst .prune.in.success,,$@))

## patterns:
##    output: {CHIP}.step2.pruning.bed.success (and bim, and fam)
##    input:  {CHIP}.step1.maf.geno.hwe.bed.success
##    input:  {CHIP}.step2.pruning.prune.in.success
## Notes: apply variant inclusion list from first pass LD pruning
%.step2.pruning.bed.success: %.step1.maf.geno.hwe.bed.success $$(subst .bed,.prune.in,$$@)
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --extract $(subst .success,,$(word 2,$^)) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: {CHIP}.step3.pruning.prune.in.success
##    input:  {CHIP}.step2.pruning.bed.success
## Notes: compute variant inclusion list from second pass LD pruning
%.step3.pruning.prune.in.success: %.step2.pruning.bed.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --indep-pairwise 50 5 0.2 --out $(subst .prune.in.success,,$@))

## patterns:
##    output: {CHIP}.step3.pruning.bed.success (and bim, and fam)
##    input:  {CHIP}.step2.pruning.bed.success
##    input:  {CHIP}.step3.pruning.prune.in.success
## Notes: apply variant inclusion list from second pass LD pruning
%.step3.pruning.bed.success: %.step2.pruning.bed.success $$(subst .bed,.prune.in,$$@)
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --extract $(subst .success,,$(word 2,$^)) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: {CHIP}.step4.het.success
##    input:  {CHIP}.step3.pruning.bed.success
## Notes: compute heterozygosity F statistics on LD pruned data
%.step4.het.success: %.step3.pruning.bed.success
	$(call qsub_handler,$(Subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --het --out $(subst .het.success,,$@))

## patterns:
##    output: {CHIP}.step4.het.remove.success
##    input:  {CHIP}.step4.het.success
## Notes: generate plink-format remove list for subjects flagged as heterozygosity outliers.
## F statistic threshold is arbitrary, using |F| > 0.2 here by default
%.step4.het.remove.success: %.step4.het.success
	$(call log_handler,$(subst .success,,$@),awk 'NR > 1 && sqrt($$6^2) > sqrt($(HET_F_MAX)^2) {print $$1"\t"$$1}' $(subst .success,,$<) > $(subst .success,,$@))

## patterns:
##    output: {CHIP}.step5.ibs-split.genome.{SPLIT-NUMBER}.gz.success
##    input:  {CHIP}.step3.pruning.bed.success
##    input:  {CHIP}.step4.het.remove.success
## Notes: generates rules for quasiparallelized plink --genome for each platform and split. Yes, this is hideous.
$(foreach platform,$(STUDIES),$(foreach subset,$(shell seq 1 $(GENOME_GZ_JOB_SPLIT)),$(platform).step5.ibs-split.genome.$(subset).gz.success)): $$(word 1,$$(subst .step5, ,$$@)).step3.pruning.bed.success $$(word 1,$$(subst .step5, ,$$@)).step4.het.remove.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --remove $(subst .success,,$(word 2,$^)) --genome gz --min $(PIHAT_MIN) --parallel $(word 2,$(subst .genome., ,$(subst .gz.success,,$@))) $(GENOME_GZ_JOB_SPLIT) --out $(word 1,$(subst .ibs-split, ,$@)).ibs-split)

## patterns:
##    output: {CHIP}.step5.ibs-split.genome.gz.success
##    input:  {CHIP}.step5.ibs-split.genome.{EACH-SPLIT-NUMBER}.gz.success
## Notes: merging function for combining quasiparallelized --genome runs. also effectively controls which studies have this applied to them
$(patsubst %,%.step5.ibs-split.genome.gz.success,$(LARGE_STUDIES)): $$(patsubst %,$$(subst .gz.success,,$$@).%.gz.success,$$(shell seq 1 $(GENOME_GZ_JOB_SPLIT)))
	$(call qsub_handler,$(subst .success,,$@),gunzip -c $(subst .success,,$^) | gzip -c > $(subst .success,,$@))

## patterns:
##    output: {CHIP}.step5.ibs-normal.genome.gz.success
##    input:  {CHIP}.step3.pruning.bed.success
##    input:  {CHIP}.step4.het.remove.success
## Notes: controller function for non-parallelized plink --genome for sufficiently small datasets
%.step5.ibs-normal.genome.gz.success: %.step3.pruning.bed.success %.step4.het.remove.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --remove $(subst .success,,$(word 2,$^)) --genome gz --min $(PIHAT_MIN) --out $(subst .genome.gz.success,,$@))

## patterns:
##    output: {CHIP}.step7.evec.success
##    input:  {CHIP}.pca.par.success
## Notes: run eigenstrat smartpca fastmode
%.step7.evec.success: %.pca.par.success
	$(call qsub_handler,$(subst .success,,$@),$(SMARTPCA) -p $(subst .success,,$(word 4,$^)))

## patterns:
##    output: {CHIP}.pca.par.success
##    input:  {CHIP}.step6.bed.success
##    input:  {CHIP}.step6.snp.success
##    input:  {CHIP}.step6.ind.success
##    input:  {CHIP}.pca.poplist.success
## Notes: generate smartpca parameter file. inputs are just to modify when it's rebuilt
%.pca.par.success: %.step6.bed.success %.step6.snp.success %.step6.ind.success %.pca.poplist.success
	$(call log_handler,$(subst .success,,$@),echo -e "genotypename: $(subst .success,,$<)\nsnpname: $(subst .success,,$(word 2,$^))\nindivname: $(subst .success,,$(word 3,$^))\nevecoutname: $(subst .pca.par,,$@).step7.evec\naltnormstyle: NO\nnumoutevec: 10\nnumoutlieriter: 5\nnumoutlierevec: 2\noutliersigmathresh: 6.0\nqtmode: 0\nfastmode: 1\npoplist: $(subst .success,,$(lastword $^))" > $(subst .success,,$@))

## patterns:
##    output: {CHIP}.pca.poplist.success
## Notes: generate smartpca population summary list
%.pca.poplist.success:
	$(call log_handler,$(subst .success,,$@),echo -e "case\ncontrol\nunknown" > $(subst .success,,$@))

## patterns:
##    output: {CHIP}.step6.snp.success
##    input:  {CHIP}.step6.bed.success (really bim)
## Notes: eigenstrat/smartpca formats are weird, so reformat bimfile accordingly.
## input is .bed.success due to how plink reformatting commands are tracked.
%.step6.snp.success: %.step6.bed.success
	$(call log_handler,$(subst .success,,$@),awk '{print $$2"\t"$$1"\t"$$4/100000000"\t"$$4"\t"$$5"\t"$$6}' $(subst .bed.success,.bim,$<) > $(subst .success,,$@))

## patterns:
##    output: {CHIP}.step6.ind.success
##    input:  {CHIP}.step6.bed.success (really fam)
## Notes: eigenstrat/smartpca formats are weird, so reformat bimfile according.
## input is .bed.success due to how plink reformatting commands are tracked.
%.step6.ind.success: %.step6.bed.success
	$(call log_handler,$(subst .success,,$@),awk '$$5 == 2 {$$5 = "F"} ; $$5 == 1 {$$5 = "M"} ; $$6 == 2 {print $$1" "$$5" case"} ; $$6 == 1 {print $$1" "$$5" control"} ; $$6 != 1 && $$6 != 2 {print $$1" "$$5" unknown"}' $(subst .bed.success,.fam,$<) > $(subst .success,,$@))

## patterns:
##    output: {CHIP}.step6.bed.success (and bim, and fam)
##    input:  {CHIP}.step3.pruning.bed.success
##    input:  {CHIP}.step4.het.remove.success
## Notes: remove heterozygosity outliers and prepare for smartpca.
%.step6.bed.success: %.step3.pruning.bed.success %.step4.het.remove.success
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --remove $(subst .success,,$(word 2,$^)) --make-bed --out $(subst .bed.success,,$@))
